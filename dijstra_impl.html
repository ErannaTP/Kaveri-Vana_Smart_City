<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Paths from Mysore(Using Dijstra's Algorithm) - Book Style</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1, h2 {
            color: #333;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
        }
        table {
            width: 80%;
            margin: 20px auto;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>

    <h1>Shortest Paths from Mysore - Implementation and Output</h1>

    <h2>Code Implementation</h2>
    <pre>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <limits>

using namespace std;

const int INF = numeric_limits<int>::max();

void dijkstra(const unordered_map<string, vector<pair<string, int>>> &graph, const string &startCity) {
    unordered_map<string, int> distances;
    unordered_map<string, string> previous;
    set<pair<int, string>> pq;

    // Initialize distances to infinity and set the start city's distance to 0
    for (const auto &node : graph) {
        distances[node.first] = INF;
    }
    distances[startCity] = 0;
    pq.insert({0, startCity});

    while (!pq.empty()) {
        string currentCity = pq.begin()->second;
        pq.erase(pq.begin());

        for (const auto &neighbor : graph.at(currentCity)) {
            string neighborCity = neighbor.first;
            int weight = neighbor.second;

            if (distances[currentCity] + weight < distances[neighborCity]) {
                pq.erase({distances[neighborCity], neighborCity});
                distances[neighborCity] = distances[currentCity] + weight;
                pq.insert({distances[neighborCity], neighborCity});
                previous[neighborCity] = currentCity;
            }
        }
    }

    // Output the shortest paths
    cout << "Shortest paths from " << startCity << ":\n";
    for (const auto &entry : distances) {
        cout << "To " << entry.first << " - Distance: " << entry.second;

        if (entry.second != INF) {
            string path = entry.first;
            string temp = entry.first;
            while (previous.find(temp) != previous.end()) {
                temp = previous[temp];
                path = temp + " -> " + path;
            }
            cout << ", Path: " << path;
        }
        cout << endl;
    }
}

int main() {
    unordered_map<string, vector<pair<string, int>>> graph = {
        {"Mysore", {{"Bangalore", 150}, {"Mandya", 45}, {"Coorg", 120}}},
        {"Bangalore", {{"Mysore", 150}, {"Tumkur", 70}, {"Chennai", 350}, {"Hosur", 50}}},
        {"Mandya", {{"Mysore", 45}, {"Bangalore", 110}}},
        {"Tumkur", {{"Bangalore", 70}, {"Davangere", 150}}},
        {"Chennai", {{"Bangalore", 350}, {"Pondicherry", 160}}},
        {"Coorg", {{"Mysore", 120}, {"Hassan", 100}}},
        {"Hosur", {{"Bangalore", 50}, {"Krishnagiri", 40}}},
        {"Davangere", {{"Tumkur", 150}}},
        {"Pondicherry", {{"Chennai", 160}}},
        {"Hassan", {{"Coorg", 100}, {"Chikmagalur", 80}}},
        {"Krishnagiri", {{"Hosur", 40}}},
        {"Chikmagalur", {{"Hassan", 80}}}
    };

    string startCity;
    cout << "Enter the starting city: ";
    cin >> startCity;

    if (graph.find(startCity) != graph.end()) {
        dijkstra(graph, startCity);
    } else {
        cout << "City not found in the network." << endl;
    }

    return 0;
}
    </pre>

    <h2>Sample Output</h2>
    <p>Enter the starting city: Mysore</p>
    <p>Shortest paths from Mysore:</p>
    <table>
        <tr>
            <th>Destination</th>
            <th>Distance</th>
            <th>Path</th>
        </tr>
        <tr>
            <td>Mysore</td>
            <td>0</td>
            <td>Mysore</td>
        </tr>
        <tr>
            <td>Mandya</td>
            <td>45</td>
            <td>Mysore → Mandya</td>
        </tr>
        <tr>
            <td>Tumkur</td>
            <td>220</td>
            <td>Mysore → Bangalore → Tumkur</td>
        </tr>
        <tr>
            <td>Krishnagiri</td>
            <td>240</td>
            <td>Mysore → Bangalore → Hosur → Krishnagiri</td>
        </tr>
        <tr>
            <td>Chikmagalur</td>
            <td>300</td>
            <td>Mysore → Coorg → Hassan → Chikmagalur</td>
        </tr>
        <tr>
            <td>Hosur</td>
            <td>200</td>
            <td>Mysore → Bangalore → Hosur</td>
        </tr>
        <tr>
            <td>Coorg</td>
            <td>120</td>
            <td>Mysore → Coorg</td>
        </tr>
        <tr>
            <td>Bangalore</td>
            <td>150</td>
            <td>Mysore → Bangalore</td>
        </tr>
        <tr>
            <td>Hassan</td>
            <td>220</td>
            <td>Mysore → Coorg → Hassan</td>
        </tr>
        <tr>
            <td>Davangere</td>
            <td>370</td>
            <td>Mysore → Bangalore → Tumkur → Davangere</td>
        </tr>
        <tr>
            <td>Pondicherry</td>
            <td>660</td>
            <td>Mysore → Bangalore → Chennai → Pondicherry</td>
        </tr>
        <tr>
            <td>Chennai</td>
            <td>500</td>
            <td>Mysore → Bangalore → Chennai</td>
        </tr>
    </table>

</body>
</html>
