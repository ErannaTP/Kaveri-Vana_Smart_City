<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segment Tree Example - Bus Schedules</title>
    <style>
        table {
            width: 70%;
            margin: 20px auto;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
    </style>
</head>
<body>

<h2>Segment Tree Example</h2>

<p>This example demonstrates a Segment Tree to manage and query bus arrival times across various cities.</p>

<div>
    <h3>Segment Tree Implementation</h3>

    <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;climits&gt;
    #include &lt;algorithm&gt;  // For sorting
    using namespace std;

    // Segment Tree node structure
    struct Node {
        int minTime;  // Minimum bus arrival time
        int maxTime;  // Maximum bus arrival time
        vector&lt;pair&lt;string, int&gt;&gt; allTimes;  // List of (City Name, Arrival Time) pairs
    };

    // Segment Tree class
    class SegmentTree {
    private:
        vector&lt;Node&gt; tree;
        vector&lt;pair&lt;string, int&gt;&gt; data;  // Pair of (City Name, Arrival Time)
        int n;

        // Building the Segment Tree
        void build(int start, int end, int node) {
            if (start == end) {
                // Leaf node: single element
                tree[node] = {data[start].second, data[start].second, {data[start]}};
            } else {
                int mid = (start + end) / 2;
                build(start, mid, 2 * node);          // Left child
                build(mid + 1, end, 2 * node + 1);    // Right child

                // Internal node: combine results from children
                tree[node].minTime = min(tree[2 * node].minTime, tree[2 * node + 1].minTime);
                tree[node].maxTime = max(tree[2 * node].maxTime, tree[2 * node + 1].maxTime);

                // Combine all city times from left and right child
                tree[node].allTimes.insert(tree[node].allTimes.end(),
                                           tree[2 * node].allTimes.begin(),
                                           tree[2 * node].allTimes.end());
                tree[node].allTimes.insert(tree[node].allTimes.end(),
                                           tree[2 * node + 1].allTimes.begin(),
                                           tree[2 * node + 1].allTimes.end());

                // Sort and remove duplicates
                sort(tree[node].allTimes.begin(), tree[node].allTimes.end(),
                     [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
                         return a.second < b.second;
                     });
                auto last = unique(tree[node].allTimes.begin(), tree[node].allTimes.end(),
                                  [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
                                      return a.first == b.first && a.second == b.second;
                                  });
                tree[node].allTimes.erase(last, tree[node].allTimes.end());
            }
        }

        // Query function
        Node query(int start, int end, int node, int left, int right) {
            if (right < start || end < left) {
                return {INT_MAX, INT_MIN, {}};  // Out of range
            }
            if (left <= start && end <= right) {
                return tree[node];  // Fully in range
            }

            int mid = (start + end) / 2;
            Node leftResult = query(start, mid, 2 * node, left, right);
            Node rightResult = query(mid + 1, end, 2 * node + 1, left, right);

            Node result;
            result.minTime = min(leftResult.minTime, rightResult.minTime);
            result.maxTime = max(leftResult.maxTime, rightResult.maxTime);

            // Combine and sort times from both sides
            result.allTimes.insert(result.allTimes.end(),
                                   leftResult.allTimes.begin(),
                                   leftResult.allTimes.end());
            result.allTimes.insert(result.allTimes.end(),
                                   rightResult.allTimes.begin(),
                                   rightResult.allTimes.end());
            sort(result.allTimes.begin(), result.allTimes.end(),
                 [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
                     return a.second < b.second;
                 });

            // Remove duplicates
            auto last = unique(result.allTimes.begin(), result.allTimes.end(),
                              [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
                                  return a.first == b.first && a.second == b.second;
                              });
            result.allTimes.erase(last, result.allTimes.end());

            return result;
        }

        // Update function
        void update(int start, int end, int node, int index, int value) {
            if (start == end) {
                // Leaf node: update the single element
                if (data[index].second != value) {  // Only update if value changes
                    data[index].second = value;
                    tree[node] = {value, value, {data[index]}};
                }
            } else {
                int mid = (start + end) / 2;
                if (index <= mid) {
                    update(start, mid, 2 * node, index, value);       // Update left child
                } else {
                    update(mid + 1, end, 2 * node + 1, index, value); // Update right child
                }

                // After update, recombine the results
                tree[node].minTime = min(tree[2 * node].minTime, tree[2 * node + 1].minTime);
                tree[node].maxTime = max(tree[2 * node].maxTime, tree[2 * node + 1].maxTime);

                // Combine and sort times from left and right
                tree[node].allTimes.insert(tree[node].allTimes.end(),
                                           tree[2 * node].allTimes.begin(),
                                           tree[2 * node].allTimes.end());
                tree[node].allTimes.insert(tree[node].allTimes.end(),
                                           tree[2 * node + 1].allTimes.begin(),
                                           tree[2 * node + 1].allTimes.end());
                sort(tree[node].allTimes.begin(), tree[node].allTimes.end(),
                     [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
                         return a.second < b.second;
                     });

                // Remove duplicates
                auto last = unique(tree[node].allTimes.begin(), tree[node].allTimes.end(),
                                  [](pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) {
                                      return a.first == b.first && a.second == b.second;
                                  });
                tree[node].allTimes.erase(last, tree[node].allTimes.end());
            }
        }

    public:
        SegmentTree(vector&lt;pair&lt;string, int&gt;&gt; &arr) {
            n = arr.size();
            data = arr;
            tree.resize(4 * n);  // Allocate space for segment tree
            build(0, n - 1, 1);  // Initialize the tree
        }

        Node query(int left, int right) {
            return query(0, n - 1, 1, left, right);
        }

        void update(int index, int value) {
            update(0, n - 1, 1, index, value);
        }
    };

    int main() {
        // Example data: Cities with bus arrival times from a source city
        vector&lt;pair&lt;string, int&gt;&gt; busSchedules = {
            {"Mysore Central", 10}, {"K.R. Nagar", 15}, {"H.D. Kote", 20},
            {"Nanjangud", 25}, {"Chamundi Hill", 30}, {"Hunsur", 35},
            {"Gonikoppal", 40}, {"Shreeramapura", 45}, {"Periyapatna", 50},
            {"Mandya", 55}
        };

        SegmentTree segTree(busSchedules);

        // Displaying the initial bus schedules
        cout &lt;&lt; "Initial Bus Schedules:\n";
        cout &lt;&lt; "----------------------------------------\n";
        cout &lt;&lt; "| City           | Arrival Time |\n";
        cout &lt;&lt; "----------------------------------------\n";
        for (auto &time : segTree.query(0, busSchedules.size() - 1).allTimes) {
            cout &lt;&lt; "| " &lt;&lt; time.first &lt;&lt; " | " &lt;&lt; time.second &lt;&lt; " |\n";
        }
        cout &lt;&lt; "----------------------------------------\n";

        // Update bus arrival time for "Periyapatna"
        segTree.update(8, 42);

        // Displaying updated bus schedules
        cout &lt;&lt; "\nUpdated Bus Schedules:\n";
        cout &lt;&lt; "----------------------------------------\n";
        cout &lt;&lt; "| City           | Arrival Time |\n";
        cout &lt;&lt; "----------------------------------------\n";
        for (auto &time : segTree.query(0, busSchedules.size() - 1).allTimes) {
            cout &lt;&lt; "| " &lt;&lt; time.first &lt;&lt; " | " &lt;&lt; time.second &lt;&lt; " |\n";
        }
        cout &lt;&lt; "----------------------------------------\n";

        return 0;
    }
    </pre>
</div>

</body>
</html>
