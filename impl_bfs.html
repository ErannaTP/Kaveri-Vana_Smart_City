<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFS Traversal</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
        }
        code {
            display: block;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
        }
        .output {
            background-color: #f0f0f0;
            padding: 10px;
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<h2>BFS Traversal Code</h2>
<code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;

using namespace std;

// Graph representation using adjacency list
class Graph {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;

public:
    Graph(int V);
    void addEdge(int u, int v);
    void emergencyResponse(int src, vector&lt;string&gt;&amp; cityNames);
};

Graph::Graph(int V) {
    this-&gt;V = V;
    adj.resize(V);
}

void Graph::addEdge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u); // For undirected graph
}

void Graph::emergencyResponse(int src, vector&lt;string&gt;&amp; cityNames) {
    vector&lt;int&gt; dist(V, INT_MAX); // Distance vector initialized to infinity
    queue&lt;int&gt; q;

    dist[src] = 0; // Distance to source is 0
    q.push(src);   // Start BFS from the source

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : adj[u]) {
            if (dist[u] + 1 &lt; dist[v]) { // Update distance if a shorter path is found
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }

    // Displaying the shortest routes
    cout &lt;&lt; "\\nEmergency Response Routing from: " &lt;&lt; cityNames[src] &lt;&lt; "\\n";
    cout &lt;&lt; "-------------------------------------------------\\n";
    cout &lt;&lt; "City Name\\t\\t\\tDistance (in hops)\\n";
    cout &lt;&lt; "-------------------------------------------------\\n";
    for (int i = 0; i &lt; V; i++) {
        cout &lt;&lt; cityNames[i] &lt;&lt; "\\t\\t\\t" &lt;&lt; dist[i] &lt;&lt; "\\n";
    }
}

int main() {
    int numCities = 6;
    Graph g(numCities);

    // Adding edges (representing roads) between cities
    g.addEdge(0, 1); // Kaveri Vana City Center to Park Avenue
    g.addEdge(0, 2); // Kaveri Vana City Center to Industrial Hub
    g.addEdge(1, 3); // Park Avenue to Residential Sector A
    g.addEdge(1, 4); // Park Avenue to Residential Sector B
    g.addEdge(2, 5); // Industrial Hub to Tourist Spot

    // City names
    vector&lt;string&gt; cityNames = {
        "Kaveri Vana City Center", // Node 0
        "Park Avenue",             // Node 1
        "Industrial Hub",          // Node 2
        "Residential Sector A",    // Node 3
        "Residential Sector B",    // Node 4
        "Tourist Spot"             // Node 5
    };

    // Emergency Response System: Choose a source city
    int sourceCity = 0; // Assume the emergency center is at "Kaveri Vana City Center"
    cout &lt;&lt; "Initiating Emergency Response System...\\n";
    g.emergencyResponse(sourceCity, cityNames);

    return 0;
}
</code>

<div class="output">
<h3>Output</h3>
<p>Initiating Emergency Response System...</p>
<p>Emergency Response Routing from: Kaveri Vana City Center</p>
<p>-------------------------------------------------</p>
<p>City Name                       Distance (in hops)</p>
<p>-------------------------------------------------</p>
<p>Kaveri Vana City Center                 0</p>
<p>Park Avenue                     1</p>
<p>Industrial Hub                  1</p>
<p>Residential Sector A                    2</p>
<p>Residential Sector B                    2</p>
<p>Tourist Spot                    2</p>
<p>Process returned 0 (0x0)   execution time : 0.093 s</p>
</div>

</body>
</html>
