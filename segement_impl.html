<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segment Tree Example</title>
    <style>
        table {
            width: 50%;
            margin: 20px auto;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
    </style>
</head>
<body>

<h2>Segment Tree Example</h2>

<!-- Segment Tree Implementation -->
<script>
// Segment Tree node structure
class Node {
    constructor(minTime, maxTime, allTimes) {
        this.minTime = minTime;  // Minimum bus arrival time
        this.maxTime = maxTime;  // Maximum bus arrival time
        this.allTimes = allTimes;  // List of (City Name, Arrival Time) pairs
    }
}

// Segment Tree class
class SegmentTree {
    constructor(data) {
        this.data = data;
        this.n = data.length;
        this.tree = new Array(4 * this.n);
        this.build(0, this.n - 1, 1);
    }

    // Building the Segment Tree
    build(start, end, node) {
        if (start === end) {
            // Leaf node: single element
            this.tree[node] = new Node(this.data[start].second, this.data[start].second, [this.data[start]]);
        } else {
            let mid = Math.floor((start + end) / 2);
            this.build(start, mid, 2 * node);          // Left child
            this.build(mid + 1, end, 2 * node + 1);    // Right child

            // Internal node: combine results from children
            let leftChild = this.tree[2 * node];
            let rightChild = this.tree[2 * node + 1];

            this.tree[node] = new Node(
                Math.min(leftChild.minTime, rightChild.minTime),
                Math.max(leftChild.maxTime, rightChild.maxTime),
                [...leftChild.allTimes, ...rightChild.allTimes]
            );

            // Sort and remove duplicates
            this.tree[node].allTimes.sort((a, b) => a.second - b.second);
            this.tree[node].allTimes = this.tree[node].allTimes.filter(
                (value, index, self) => self.findIndex(t => t.first === value.first && t.second === value.second) === index
            );
        }
    }

    // Query function
    query(start, end, node, left, right) {
        if (right < start || end < left) {
            return new Node(Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, []);
        }
        if (left <= start && end <= right) {
            return this.tree[node];
        }

        let mid = Math.floor((start + end) / 2);
        let leftResult = this.query(start, mid, 2 * node, left, right);
        let rightResult = this.query(mid + 1, end, 2 * node + 1, left, right);

        let result = new Node(
            Math.min(leftResult.minTime, rightResult.minTime),
            Math.max(leftResult.maxTime, rightResult.maxTime),
            [...leftResult.allTimes, ...rightResult.allTimes]
        );

        result.allTimes.sort((a, b) => a.second - b.second);
        result.allTimes = result.allTimes.filter(
            (value, index, self) => self.findIndex(t => t.first === value.first && t.second === value.second) === index
        );

        return result;
    }

    // Update function
    update(start, end, node, index, value) {
        if (start === end) {
            // Leaf node: update the single element
            if (this.data[index].second !== value) {  // Only update if value changes
                this.data[index].second = value;
                this.tree[node] = new Node(value, value, [this.data[index]]);
            }
        } else {
            let mid = Math.floor((start + end) / 2);
            if (index <= mid) {
                this.update(start, mid, 2 * node, index, value);       // Update left child
            } else {
                this.update(mid + 1, end, 2 * node + 1, index, value); // Update right child
            }

            // After update, recombine the results
            let leftChild = this.tree[2 * node];
            let rightChild = this.tree[2 * node + 1];

            this.tree[node] = new Node(
                Math.min(leftChild.minTime, rightChild.minTime),
                Math.max(leftChild.maxTime, rightChild.maxTime),
                [...leftChild.allTimes, ...rightChild.allTimes]
            );

            // Sort and remove duplicates
            this.tree[node].allTimes.sort((a, b) => a.second - b.second);
            this.tree[node].allTimes = this.tree[node].allTimes.filter(
                (value, index, self) => self.findIndex(t => t.first === value.first && t.second === value.second) === index
            );
        }
    }

    queryWrapper(left, right) {
        return this.query(0, this.n - 1, 1, left, right);
    }

    updateWrapper(index, value) {
        this.update(0, this.n - 1, 1, index, value);
    }
}

window.onload = function() {
    let busSchedules = [
        { first: "Mysore Central", second: 10 },
        { first: "K.R. Nagar", second: 15 },
        { first: "H.D. Kote", second: 20 },
        { first: "Nanjangud", second: 25 },
        { first: "Chamundi Hill", second: 30 },
        { first: "Hunsur", second: 35 },
        { first: "Gonikoppal", second: 40 },
        { first: "Shreeramapura", second: 45 },
        { first: "Periyapatna", second: 50 },
        { first: "Mandya", second: 55 }
    ];

    let segTree = new SegmentTree(busSchedules);

    // Displaying the initial bus schedules
    displaySchedules(segTree.queryWrapper(0, busSchedules.length - 1).allTimes);

    // Update bus arrival time for "Periyapatna"
    document.getElementById("updateButton").addEventListener("click", function() {
        segTree.updateWrapper(8, 42);
        displaySchedules(segTree.queryWrapper(0, busSchedules.length - 1).allTimes);
    });

    function displaySchedules(times) {
        let table = document.getElementById("scheduleTable");
        let output = "<tr><th>City</th><th>Arrival Time</th></tr>";
        times.forEach(function(time) {
            output += `<tr><td>${time.first}</td><td>${time.second}</td></tr>`;
        });
        table.innerHTML = output;
    }
};
</script>

<!-- HTML Table for displaying schedules -->
<table id="scheduleTable">
    <!-- Data will be dynamically injected here -->
</table>

<!-- Button to trigger update -->
<button id="updateButton">Update</button>

</body>
</html>
